{"entries":[{"timestamp":1738336695893,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"let numwaitingareas: number;\nlet tagSizes: number[];\nlet i: number;\nlet CollisionDetection = false\nlet RandomDestination = true\n//  random object or object based on own ID\nlet HIL_Simulation = false\n//  run code on\nlet FirstClaimDestination = true\n//  True: wait for destination area te be cleared.\n//  False: turn towards destination even if it is occupied\nlet UseFleetmanager = false\nlet Full_auto = false\nlet ID = 4\nlet DEBUG = false\nlet UseHusky = true\nlet DisplayDelay = 200\nfunction showText(txt: string) {\n    // if not HIL_Simulation:\n    if (UseHusky) {\n        txt = \"\" + ID + \" \" + txt\n        huskylens.clearOSD()\n        huskylens.writeOSD(txt, 30, 30)\n        if (HIL_Simulation) {\n            basic.pause(DisplayDelay)\n        }\n        \n    }\n    \n}\n\n// #####################################\nserial.redirectToUSB()\nserial.writeString(\"I am alive\")\nif (!HIL_Simulation || UseHusky) {\n    huskylens.initI2c()\n    huskylens.initMode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\n}\n\nbasic.pause(1000)\n// #####################################\n//  number of robots\nlet numrobots = 1\n//  number of 'plastic' object types\nlet numobjects = 4\n//  should be an even number for now\nlet numtargets = numobjects\n//  buffer zones for wating robots\n//  1 robot = 1 waiting\n//  2 robot = 1 waiting, 1 on storage location\n//  3 robot = 3 waiting, 1 left, 1 right 1 central\n//  4 robot = 5 waiting, 2 left, 2 right, 1 central\n//  5 robot = 7 waiting, 3 left, 3 right, 1 central\n//  6 robot = 9 waiting, 4 left, 4 right, 1 central\n//  7 robot = 11 waiting, 5 left, 5 right, 1 central\n//  8 robots = 13 waiting, 6 left, 6 right, 1 central\nif (numrobots == 1) {\n    numwaitingareas = 5\n} else {\n    //  adjust to demo\n    numwaitingareas = Math.max(3, (numrobots - 1) * 2 - 1)\n}\n\n//  1 central waiting area offset to the front\nlet numstorage = 1\n//  try increasing this in future scenarios, attack waste-pile from multiple locations\n//  total number of locations where robots can go\nlet numlocations = numwaitingareas + numstorage + numtargets + numobjects\n//  constants\nlet IDLE = 0\nlet DRIVEBACKWARD = 1\nlet FINDTARGET = 2\nlet GOTOTARGET = 3\nlet FINDOBJECT = 4\nlet GRABOBJECT = 5\nlet LOCATION_t = 0\n//  robot is looking for location\nlet OBJECT_t = 1\n//  robot is looking for object\nlet OPENED = 1\nlet CLOSED = 0\nlet AHEAD = 0\nlet LEFT = 1\nlet RIGHT = 2\nlet MAXSPEED = 22\nlet MINSPEED = 15\nlet MINYAWSPEED = 8\nlet MAXYAWSPEED = 14\nlet BACKUPSPEED = -20\nlet BACKUPDISTANCE = 20\nlet OBJECT_THRESHOLD = 0\n//  minimum distance to object, before closing grippers\nlet state_names = [\"IDLE\", \"DRIVEBACKWARD\", \"FINDTARGET\", \"GOTOTARGET\", \"FINDOBJECT\", \"GRABOBJECT\"]\nlet direction_names = [\"AHEAD\", \"LEFT\", \"RIGHT\"]\nlet cmd_names = [\"STATUS_UPDATE\", \"CLAIM_DESTINATION\", \"RELEASE_POSITION\", \"RELEASE_ROUTE\", \"ROBOT_START\", \"ROBOT_STOP\"]\nlet rply_names = [\"NOK\", \"OK\", \"ACK\"]\n//  commands\nlet NO_CMD = -1\nlet POSITION_UPDATE = 10\nlet STATUS_UPDATE = 0\nlet CLAIM_DESTINATION = 1\nlet RELEASE_POSITION = 2\nlet RELEASE_ROUTE = 3\nlet ROBOT_START = 4\nlet ROBOT_STOP = 5\nlet NOK = 0\nlet OK = 1\nlet ACK = 2\n// initialize variables related to huskylens\nlet t_start = 0\nlet t_last = 0\nlet dt_AI = 0\nlet inview = 0\nlet x = 0\nlet y = 0\nlet w = 0\nlet h = 0\nlet newdata = false\nlet inview_count = 0\nlet RadioTxPending = false\nlet tagsInView = [0]\nlet frame_count = 0\nlet buffer_xywh = [-1, -1, -1, -1]\nlet buffer_tagsInView = [0]\nlet tagID = 1\n//  tagIDs = [1 tm 6]\n//  tuning per robot, mainly sotrage area\nif (ID == 1) {\n    tagSizes = [0, 88, 90, 90, 90, 88, 87, 88, 88, 88, 88, 55, 55, 55, 55]\n}\n\n//  5x waiting, 1 central, 4 targets, 4 objects\nif (ID == 2) {\n    tagSizes = [0, 88, 90, 90, 90, 83, 87, 88, 88, 88, 88, 55, 55, 55, 55]\n}\n\n//  5x waiting, 1 central, 4 targets, 4 objects\nif (ID == 3) {\n    tagSizes = [0, 88, 90, 90, 90, 86, 87, 88, 88, 88, 88, 55, 55, 55, 55]\n}\n\n//  5x waiting, 1 central, 4 targets, 4 objects\nif (ID == 4) {\n    tagSizes = [0, 88, 90, 90, 90, 86, 87, 88, 88, 88, 88, 55, 55, 55, 55]\n}\n\n//  5x waiting, 1 central, 4 targets, 4 objects\nlet tagSize = tagSizes[tagID]\nlet zeroes = [0]\nwhile (i < tagSizes.length) {\n    zeroes.push(0)\n    i += 1\n}\ntagsInView = zeroes\n// start_searching = 0\n// ---------------------------------------------------------------------------------------------------------\n//  helper function to open and close grippers, will be different on actual robot\n// ---------------------------------------------------------------------------------------------------------\nfunction open_gripper(): boolean {\n    let opengripper = true\n    maqueen.servoRun(maqueen.Servos.S1, 85)\n    return opengripper\n}\n\nfunction close_gripper(): boolean {\n    let closegripper = true\n    maqueen.servoRun(maqueen.Servos.S1, 105)\n    return closegripper\n}\n\nfunction actuate_motors(): boolean {\n    if (HIL_Simulation) {\n        return true\n    }\n    \n    let left_speed = robot.speed + robot.yaw_speed\n    let right_speed = robot.speed + -robot.yaw_speed\n    // serial.write_line(str(left_speed)+\" left speed\")\n    // serial.write_line(str(right_speed)+\" right speed\")\n    //  set speed for motors here\n    if (left_speed >= 0) {\n        maqueen.motorRun(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    } else {\n        maqueen.motorRun(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    }\n    \n    if (right_speed >= 0) {\n        maqueen.motorRun(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    } else {\n        maqueen.motorRun(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n    }\n    \n    return true\n}\n\nfunction get_time(): number {\n    return input.runningTime()\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  base class of robot, can also be used on micro:Maqueen robot.\n//  Robot() class, should be same for offline Simulation and actual physical demo robot\n// ---------------------------------------------------------------------------------------------------------\nclass Robot {\n    id: number\n    location: number\n    destination: number\n    target: number\n    targettype: number\n    objecttype: number\n    state: number\n    gripper: number\n    speed: number\n    yaw_speed: number\n    active: boolean\n    run_enable: boolean\n    steering_only: boolean\n    target_direction: number\n    target_inview: boolean\n    target_locked: boolean\n    backup_distance: number\n    distance_to_target: number\n    backup_starttime: number\n    looking_for_object: number\n    route_length: number\n    route_reported: boolean\n    obstacle_detected: boolean\n    cmd: number\n    reply: number\n    constructor(loc: number = 1, dst: number = 1, _id: number = 1) {\n        //  who are we\n        this.id = _id\n        //  ego location and destination nr\n        this.location = loc\n        this.destination = dst\n        this.target = dst\n        this.targettype = LOCATION_t\n        this.objecttype = null\n        //  states\n        this.state = IDLE\n        this.gripper = CLOSED\n        this.speed = 0\n        this.yaw_speed = 0\n        //  params\n        this.active = false\n        this.run_enable = false\n        this.steering_only = false\n        //  allowed to change heading but not driving\n        this.target_direction = LEFT\n        this.target_inview = false\n        //  target is in view of camera\n        this.target_locked = false\n        //  target is straight ahead\n        this.backup_distance = 0\n        this.distance_to_target = 0\n        this.backup_starttime = 0\n        this.looking_for_object = 0\n        this.route_length = 0\n        this.route_reported = false\n        this.obstacle_detected = false\n        this.cmd = 0\n        this.reply = 0\n    }\n    \n    public gripper_open() {\n        if (open_gripper()) {\n            this.gripper = OPENED\n        }\n        \n        \n    }\n    \n    public gripper_close() {\n        if (close_gripper()) {\n            this.gripper = CLOSED\n        }\n        \n        \n    }\n    \n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  pre allocate robot instance as global\n// ---------------------------------------------------------------------------------------------------------\nlet robot = new Robot(ID, ID, ID)\n// ---------------------------------------------------------------------------------------------------------\n//  this function will be based on camera on actual robot\n// ---------------------------------------------------------------------------------------------------------\nfunction calc_heading(_robot: Robot = new Robot()): number {\n    // angle error in pixels\n    //  x = position of tag in camera view, 320 wide, 160 is center\n    if (HIL_Simulation) {\n        basic.pause(100)\n        return 0\n    }\n    \n    let angle_err = 160 - x\n    return angle_err\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  this function will be based on camera on actual robot\n// ---------------------------------------------------------------------------------------------------------\nfunction calc_distance(_robot: Robot = new Robot()): number {\n    let distance_measured: number;\n    /** \n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    \n */\n    let tagSize = tagSizes[_robot.target]\n    let tagID = _robot.target\n    if (HIL_Simulation) {\n        if (!(_robot.state == DRIVEBACKWARD)) {\n            distance_measured = _robot.distance_to_target - _robot.speed\n        } else {\n            //  drive towards target\n            distance_measured = _robot.distance_to_target + Math.abs(_robot.speed)\n        }\n        \n    } else {\n        //  drive away from target\n        distance_measured = tagSize - h\n    }\n    \n    //  height of tag - height of tag measured\n    // serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    distance_measured = Math.max(distance_measured, 0)\n    //  distance cannot be negative\n    return distance_measured\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  look for target and aim robot towards it, different in offline Simulation vs actual robot\n// ---------------------------------------------------------------------------------------------------------\nfunction find_target(_robot: Robot = new Robot()): number {\n    //  We are driving towards a location\n    if (_robot.targettype == LOCATION_t) {\n        _robot.target = _robot.destination\n    }\n    \n    //  We are looking for and driving to an object\n    if (_robot.targettype == OBJECT_t) {\n        //  start looking for the object\n        _robot.target = obj[_robot.objecttype]\n    }\n    \n    //  obj location nr will become new target\n    _robot.steering_only = true\n    //  set preffered turning direction?\n    //  actuate drive and steering\n    let _dist = move_robot(_robot)\n    return _dist\n}\n\n// ---------------------------------------------------------------------------------------------------------\n// function to search target\n// ---------------------------------------------------------------------------------------------------------\nfunction pulse(_dir: number = LEFT, _robot: Robot = new Robot()): number {\n    let time_looking: number;\n    let turn_speed: number;\n    // pulsing behaviour\n    let pulse_duration = 700\n    //  Duration of one complete pulse cycle\n    let active_ratio = 0.2\n    //  Ratio of time the robot is actively turning within a pulse\n    let base_speed = 15\n    let speed_multiplier = 1.25\n    if (robot.state == FINDOBJECT) {\n        speed_multiplier = 1.2\n        if (robot.looking_for_object == 0) {\n            _robot.looking_for_object = input.runningTime()\n        } else {\n            time_looking = input.runningTime() - _robot.looking_for_object\n            if (time_looking < 2000) {\n                _dir = LEFT\n            } else {\n                _dir = RIGHT\n            }\n            \n        }\n        \n    }\n    \n    // if start_searching == 0: # als\n    //     start_searching = input.running_time()\n    // calculate searching time\n    // searching_time = input.running_time() - start_searching\n    //  Calculate the phase of the pulse (0 to 1)\n    let pulse_phase = input.runningTime() % pulse_duration / pulse_duration\n    // calculate if we are in the active part of the pulse\n    let is_active_pulse = pulse_phase < active_ratio\n    if (is_active_pulse) {\n        //  During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    } else {\n        //  During inactive pulse: stand still\n        turn_speed = base_speed\n    }\n    \n    if (_dir == LEFT) {\n        turn_speed = -turn_speed\n    }\n    \n    return turn_speed\n}\n\n// if payload:\n//     speed_left *= 1.15\n//     speed_right *= 1.15\n// if payload:\n//     speed_left *= 1.15\n//     speed_right *= 1.15\n// ---------------------------------------------------------------------------------------------------------\n//  actual motion control, aim for target, with or without speed\n// ---------------------------------------------------------------------------------------------------------\nfunction move_robot(_robot: Robot = new Robot()): number {\n    let angle_err: number;\n    let Kp: number;\n    // check if robot is allowed to move\n    let dist_err = 999\n    //  default distance error\n    if (!_robot.run_enable) {\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n    }\n    \n    // check if target is in sight\n    if (tagsInView.indexOf(_robot.target) >= 0 || HIL_Simulation || buffer_tagsInView.indexOf(_robot.target) >= 0) {\n        _robot.target_inview = true\n    } else {\n        //  add timeout before target is no longer in view???\n        _robot.target_inview = false\n        _robot.target_locked = false\n    }\n    \n    // if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if (!_robot.target_inview) {\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction, _robot)\n    } else {\n        //  if target is in view\n        //  heading / steering control\n        angle_err = calc_heading(_robot)\n        //  how many pixels are we off centre\n        dist_err = calc_distance(_robot)\n        //  how many pixels are we away from target\n        _robot.distance_to_target = dist_err\n        //  store on instance of robot, for logistical and rouet handling\n        //  heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp\n        //  simple P-control of heading angle\n        if (_robot.target_locked) {\n            _robot.yaw_speed = Math.max(-MAXYAWSPEED, Math.min(_robot.yaw_speed, MAXYAWSPEED))\n        } else {\n            _robot.yaw_speed = Math.max(-MAXYAWSPEED, Math.min(_robot.yaw_speed, MAXYAWSPEED))\n        }\n        \n        //  speed control, start driving when target is almost straight ahead of robot\n        if (Math.abs(angle_err) < 20) {\n            _robot.yaw_speed = 0\n            _robot.target_locked = true\n            //  speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = Math.min(dist_err * Kp, MAXSPEED)\n            //  drive slow when approaching an object\n            if (_robot.state == GRABOBJECT) {\n                _robot.speed = Math.min(MINSPEED, _robot.speed * Kp)\n            }\n            \n        } else {\n            _robot.target_locked = false\n        }\n        \n        //  steering only when aiming for target\n        if (_robot.steering_only) {\n            _robot.speed = 0\n        }\n        \n        //  if obstacle detected stop robot\n        if (CollisionDetection && collision_detected(_robot)) {\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n        }\n        \n        //  adjust turning speed depening on driving or turning when standing still\n        if (_robot.speed > 0) {\n            //  while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = Math.max(-MINYAWSPEED / 4, Math.min(_robot.yaw_speed, MINYAWSPEED / 4))\n        } else {\n            //  turn while standing still, use minimum turning speed\n            if (_robot.yaw_speed > 0) {\n                if (_robot.yaw_speed < MAXYAWSPEED) {\n                    _robot.yaw_speed = MAXYAWSPEED\n                }\n                \n            }\n            \n            if (_robot.yaw_speed < 0) {\n                if (_robot.yaw_speed > -MAXYAWSPEED) {\n                    _robot.yaw_speed = -MAXYAWSPEED\n                }\n                \n            }\n            \n        }\n        \n    }\n    \n    actuate_motors()\n    return dist_err\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  actively stop robot\n// ---------------------------------------------------------------------------------------------------------\nfunction stop_robot(_robot: Robot = new Robot()) {\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  drive backward to clear storage or target areas\n// ---------------------------------------------------------------------------------------------------------\nfunction reverse_robot(_robot: Robot = new Robot()): boolean {\n    let _finished: boolean;\n    let dist_err = calc_distance(_robot)\n    //  drive straight backward, without steering\n    _robot.yaw_speed = 0\n    //  have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.runningTime() - _robot.backup_starttime < 750) {\n        //  0.75 seconds\n        _robot.looking_for_object = 0\n        // if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = false\n    } else {\n        _finished = true\n        _robot.speed = 0\n    }\n    \n    actuate_motors()\n    return _finished\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  run robot main code (similar to real-time implementation)\n// ---------------------------------------------------------------------------------------------------------\nfunction do_robot(_robot: Robot = new Robot()) {\n    let result: number[];\n    let _proceed: boolean;\n    let _dist_to_travel: number;\n    //  statemachine\n    if (_robot.state == IDLE) {\n        _robot.run_enable = false\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = POSITION_UPDATE\n        stop_robot(_robot)\n        if (_robot.active) {\n            //  we are allowed to drive\n            _robot.run_enable = true\n            //  request next destination, if we cary an object we are going to an output stream area\n            result = next_destination(_robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            if (_robot.location != waitingarea[3]) {\n                _robot.target_direction = result[1]\n            }\n            \n            _robot.target = _robot.destination\n            //  if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if (HIL_Simulation) {\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            }\n            \n            //  maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            //  when the robot has reased its starting position (claim released) the QR code should be visible\n            if (waitingarea.indexOf(_robot.location) >= 0) {\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET\n                //  directly start aiming for next destination\n                // serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + (\"\" + _robot.target) + \" \" + direction_names[_robot.target_direction])\n                //  for HIL_Simulation only\n                if (HIL_Simulation) {\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n                }\n                \n            } else {\n                //  backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                // serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD\n                //  drive backwards first\n                _robot.backup_starttime = get_time()\n                //  input.running_time()\n                //  if wa are at target area, weh open gripper and drive backward to leave object there\n                if (target.slice(1, numtargets + 1).indexOf(_robot.location) >= 0) {\n                    _robot.gripper_open()\n                    _robot.objecttype = null\n                    //  we leave the object here\n                    \n                } else {\n                    // elif _robot.location in storagearea:\n                    //  randomly assign new object to location where last object was taken from\n                    //     nxt_object = randint(1, numobjects+1)\n                    //     waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                    //     waste_object[_robot.objecttype].objecttype = nxt_object\n                    //     pass\n                    //  all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    \n                }\n                \n                //  for HIL_Simulation only\n                if (HIL_Simulation) {\n                    _robot.distance_to_target = 0\n                }\n                \n            }\n            \n        }\n        \n        \n    } else if (_robot.state == DRIVEBACKWARD) {\n        //  drive backwards\n        if (reverse_robot(_robot)) {\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + (\"\" + _robot.target) + \" \" + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            //  for HIL_Simulation only\n            if (HIL_Simulation) {\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            }\n            \n        }\n        \n        \n    } else if (_robot.state == FINDTARGET) {\n        //  find target by rotating robot, but do not drive\n        _proceed = false\n        if (FirstClaimDestination) {\n            if (UseFleetmanager) {\n                _robot.cmd = CLAIM_DESTINATION\n                if (_robot.reply == OK) {\n                    _robot.reply = 0\n                    //  reset for next command\n                    _proceed = true\n                    _robot.cmd = STATUS_UPDATE\n                }\n                \n                \n            } else if (claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id) {\n                _proceed = true\n            }\n            \n        } else {\n            _proceed = true\n        }\n        \n        if (_proceed) {\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            //  when we have found the target, we are going to drive towards it\n            if (_robot.target_locked) {\n                //  we have found the target, re-check if it is clear to drive there\n                // if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if (!FirstClaimDestination) {\n                    _proceed = false\n                    if (CollisionDetection) {\n                        _proceed = true\n                    } else if (UseFleetmanager) {\n                        _robot.cmd = CLAIM_DESTINATION\n                        if (_robot.reply == OK) {\n                            _robot.reply = 0\n                            //  reset for next command\n                            _proceed = true\n                            _robot.cmd = STATUS_UPDATE\n                        }\n                        \n                        \n                    } else if (claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id) {\n                        _proceed = true\n                    }\n                    \n                }\n                \n                if (_proceed) {\n                    showText(\"GOTOTARGET: \" + (\"\" + _robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = false\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n                }\n                \n            }\n            \n        }\n        \n        \n    } else if (_robot.state == GOTOTARGET) {\n        //  make sure we keep claim on target area\n        _robot.steering_only = false\n        _dist_to_travel = move_robot(_robot)\n        _proceed = false\n        _robot.cmd = STATUS_UPDATE\n        //  report route haflway, only onetime reporting\n        if (_dist_to_travel < _robot.route_length / 2 && !_robot.route_reported) {\n            if (UseFleetmanager) {\n                _robot.route_reported = true\n                \n                //  do not report release position\n                /** \n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n                \n */\n            } else {\n                release_position(_robot.location)\n                _robot.route_reported = true\n            }\n            \n        }\n        \n        _robot.distance_to_target = _dist_to_travel\n        //  if we approach storage, open gripper before reaching destination\n        if (storagearea.indexOf(_robot.destination) >= 0) {\n            if (_dist_to_travel == 0) {\n                _robot.state = FINDOBJECT\n                //  assign an object to look for\n                if (RandomDestination) {\n                    _robot.objecttype = randint(1, numobjects)\n                } else {\n                    //  a random object is assigned to robot\n                    _robot.objecttype = _robot.id\n                }\n                \n                //  robot ID determines object types to be retrieved\n                //  switch state and start looking for object\n                showText(\"FINDOBJECT: \" + (\"\" + _robot.objecttype))\n                \n            }\n            \n        } else if (_dist_to_travel <= 0 + 5) {\n            //  target reached, release route\n            _proceed = false\n            if (UseFleetmanager) {\n                _robot.cmd = RELEASE_ROUTE\n                if (DEBUG) {\n                    serial.writeLine(\"release route gototarget\")\n                }\n                \n                if (DEBUG) {\n                    serial.writeLine(\"reply: \" + (\"\" + _robot.reply))\n                }\n                \n                if (_robot.reply == ACK) {\n                    _robot.reply = 0\n                    //  reset for next command\n                    _proceed = true\n                    _robot.cmd = STATUS_UPDATE\n                }\n                \n                \n            } else {\n                release_route(_robot.location, _robot.destination)\n                _proceed = true\n            }\n            \n            //  update position\n            if (_proceed) {\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n            }\n            \n        }\n        \n        \n    } else if (_robot.state == FINDOBJECT) {\n        //  Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = true\n        //  if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if (_robot.target_locked) {\n            _robot.steering_only = false\n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + (\"\" + _robot.objecttype))\n        }\n        \n    } else if (_robot.state == GRABOBJECT) {\n        _dist_to_travel = move_robot(_robot)\n        if (_dist_to_travel <= OBJECT_THRESHOLD + 5) {\n            _robot.gripper_close()\n            _proceed = false\n            //  target reached, release route\n            if (UseFleetmanager) {\n                _robot.cmd = RELEASE_ROUTE\n                if (DEBUG) {\n                    serial.writeLine(\"release route grabobject\")\n                }\n                \n                if (_robot.reply == ACK) {\n                    _robot.reply = 0\n                    //  reset for next command\n                    _proceed = true\n                    _robot.cmd = STATUS_UPDATE\n                }\n                \n                \n            } else {\n                release_route(_robot.location, _robot.destination)\n                _proceed = true\n            }\n            \n            //  update position\n            if (_proceed) {\n                _robot.location = _robot.destination\n                //  switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n            }\n            \n        }\n        \n        \n    }\n    \n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  collision detection, can be based on camera or sensor on robot\n// ---------------------------------------------------------------------------------------------------------\nfunction collision_detected(_robot: Robot = new Robot()): boolean {\n    // \n    //  Needs implementing on robot\n    // \n    _robot.obstacle_detected = false\n    let obstacle_detected = false\n    return obstacle_detected\n}\n\n// ---------------------------------------------------------------------------------------------------------\n// \n//   ROUTE HANDLING BELOW\n// \n// ---------------------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------------------\n//  locations id's\n// ---------------------------------------------------------------------------------------------------------\n//  ids of waiting areas\nlet waitingarea = [0]\nfor (i = 0; i < numwaitingareas; i++) {\n    waitingarea.push(i + 1)\n}\n//  ids of storage areas\nlet storagearea = [0]\nfor (i = numwaitingareas; i < numwaitingareas + numstorage; i++) {\n    storagearea.push(i + 1)\n}\n//  ids of target areas\nlet target = [0]\nfor (i = numwaitingareas + numstorage; i < numwaitingareas + numstorage + numtargets; i++) {\n    target.push(i + 1)\n}\n//  ids of objects\nlet obj = [0]\nfor (i = numwaitingareas + numstorage + numtargets; i < numwaitingareas + numstorage + numtargets + numobjects; i++) {\n    obj.push(i + 1)\n}\n// occupation list of all locations\n// occupying = [0]  * (numlocations +1) -> does not work in Makecode\n//  for compatibility reasons wit MakeCode on robot, do it like this\nlet occupying = [0]\nfor (i = 0; i < numlocations + 1; i++) {\n    occupying.push(0)\n}\nlet locationnames = [\"None\"]\nfor (i = 1; i < numwaitingareas + 1; i++) {\n    locationnames.push(\"\" + \"waitingarea \" + (\"\" + i))\n}\nlocationnames.push(\"\" + \"storage 1\")\nfor (i = 1; i < numobjects + 1; i++) {\n    locationnames.push(\"\" + \"targetarea \" + (\"\" + i))\n}\nfor (i = 0; i < numobjects + 1; i++) {\n    locationnames.push(\"\" + \"object \" + (\"\" + (i + 1)))\n}\n// ---------------------------------------------------------------------------------------------------------\n//  instances of routes, using location id's\n// ---------------------------------------------------------------------------------------------------------\nlet routes = [[0, 0]]\nfor (i = 0; i < 50; i++) {\n    routes.push([0, 0])\n}\n//  route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor (i = 0; i < numwaitingareas; i++) {\n    routes[i] = [waitingarea[1 + i], storagearea[1]]\n}\nlet offset = numwaitingareas\nfor (i = 0; i < numobjects; i++) {\n    routes[i + offset] = [storagearea[1], target[1 + i]]\n}\noffset += i + 1\nfor (i = 0; i < numobjects; i++) {\n    if (i < numobjects / 2) {\n        routes[i + offset] = [target[i + 1], waitingarea[1]]\n    } else {\n        routes[i + offset] = [target[i + 1], waitingarea[waitingarea.length - 1]]\n    }\n    \n}\n//  waitingarea[-1] is not compatibel with Makecode\noffset += i + 1\nlet idx = 0\nfor (i = 1; i < numwaitingareas; i++) {\n    if (i < numwaitingareas / 2) {\n        routes[offset + i - 1] = [waitingarea[i], waitingarea[i + 1]]\n        //  shift from left to middle\n        idx = i\n    } else {\n        routes[offset + i - 1] = [waitingarea[waitingarea.length - 1] - i + idx + 1, waitingarea[waitingarea.length - 1] - i + idx]\n    }\n    \n}\n//  shift from right to middle\n//  potentially crossing route combinations for additional clearance check\n//  crossing routes:\n//  - all routes from storage to targets in combination with all targets to waitingarea\n//  - combination have to be all on left side or right side, right and left never cross (for now)\nlet crossing_routes_ids = [[[0, 0], [0, 0]]]\nlet crossing_routes = [[0, 0]]\nfor (i = 0; i < routes.length; i++) {\n    if (routes[i][0] == storagearea[1]) {\n        for (let j = 0; j < routes.length; j++) {\n            if (routes[j][1] == waitingarea[1]) {\n                if (routes[j][0] < routes[i][1]) {\n                    if (target.slice(1, Math.trunc(numtargets / 2) + 1).indexOf(routes[i][1]) >= 0) {\n                        crossing_routes_ids.push([routes[i], routes[j]])\n                        crossing_routes.push([i, j])\n                    }\n                    \n                }\n                \n            }\n            \n            if (routes[j][1] == waitingarea[waitingarea.length - 1]) {\n                if (routes[j][0] < routes[i][1]) {\n                    if (target.slice(Math.trunc(numtargets / 2) + 1, numtargets + 1).indexOf(routes[i][1]) >= 0) {\n                        crossing_routes_ids.push([routes[i], routes[j]])\n                        crossing_routes.push([i, j])\n                    }\n                    \n                }\n                \n            }\n            \n        }\n    }\n    \n}\nlet active_routes = [false]\nfor (i = 0; i < routes.length + 1; i++) {\n    active_routes.push(false)\n}\nlet crossed_routes = [false]\nfor (i = 0; i < routes.length + 1; i++) {\n    crossed_routes.push(false)\n}\n// ---------------------------------------------------------------------------------------------------------\n//  check what next destination will be, this is the route scheduler, might be local or remote implemented\n// ---------------------------------------------------------------------------------------------------------\nfunction next_destination(_location: number, objecttype: number = null): number[] {\n    let nxt_dest = _location\n    //  if there is no new location found, return current position as next destination\n    let target_dir = AHEAD\n    //  if we pick up an object, object nr tels us where to go\n    if (storagearea.indexOf(_location) >= 0 && objecttype !== null) {\n        //  were need the collected object go to?\n        nxt_dest = target[objecttype]\n        //  is target location left or rigth of us?\n        if (target.slice(1, Math.trunc(numtargets / 2) + 1).indexOf(nxt_dest) >= 0) {\n            target_dir = LEFT\n        } else if (target.slice(Math.trunc(numtargets / 2) + 1, numtargets + 1).indexOf(nxt_dest) >= 0) {\n            target_dir = RIGHT\n        }\n        \n    } else if (target.slice(1, Math.trunc(numtargets / 2) + 1).indexOf(_location) >= 0) {\n        //  if we come from a target to the left, goto left most waiting area\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    } else if (target.slice(Math.trunc(numtargets / 2) + 1, numtargets + 1).indexOf(_location) >= 0) {\n        //  if we come from a taget to the right, goto right most waiting area\n        nxt_dest = waitingarea[waitingarea.length - 1]\n        target_dir = RIGHT\n    } else if (waitingarea.indexOf(_location) >= 0) {\n        //  if we are in the waiting area, move toward the center wating area, before going back to the storage\n        //  from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for (let i = 1; i < Math.trunc(numwaitingareas / 2) + 1; i++) {\n            //  from left to middle\n            if (_location == waitingarea[i]) {\n                nxt_dest = waitingarea[i + 1]\n                target_dir = LEFT\n            }\n            \n            //  from right to middle\n            if (_location == waitingarea[waitingarea.length - 1] - i + 1) {\n                nxt_dest = waitingarea[waitingarea.length - 1] - i\n                target_dir = RIGHT\n            }\n            \n        }\n    }\n    \n    return [nxt_dest, target_dir]\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n// ---------------------------------------------------------------------------------------------------------\nfunction claim_destination(_loc: number = 0, _dest: number = 0, _id: number = 0): number[] {\n    let claimed_id: number;\n    let claimed = 0\n    let occupied = occupying[_dest]\n    if (occupied == 0 && _id > 0) {\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    } else {\n        claimed_id = occupying[_dest]\n    }\n    \n    if (claimed_id == _id && _id > 0) {\n        if (check_routes(_loc, _dest, _id)) {\n            occupying[_dest] = _id\n        } else {\n            // release_position(_loc) # this assumes that you start driving imediatly after claim of location\n            claimed_id = 0\n        }\n        \n    }\n    \n    return [claimed, claimed_id]\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  check if a destination is occupied, return ID that occupies destination\n// ---------------------------------------------------------------------------------------------------------\nfunction check_occupied(_dst: number) {\n    let [claimed, occupied] = claim_destination(0, _dst)\n    return occupied\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  release location when you have left it\n// ---------------------------------------------------------------------------------------------------------\nfunction release_position(_location: number): boolean {\n    occupying[_location] = 0\n    return true\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  release a route when we finished driving it\n// ---------------------------------------------------------------------------------------------------------\nfunction release_route(_loc: number, _dest: number) {\n    let _route_nr: number;\n    let _route = [_loc, _dest]\n    // if _route in [r for r in routes]: # not compatible with makecode\n    let _found = false\n    for (let i = 0; i < routes.length; i++) {\n        if (_route == routes[i]) {\n            _found = true\n        }\n        \n    }\n    if (_found) {\n        //  get route nr\n        _route_nr = _py.py_array_index(routes, _route)\n        active_routes[_route_nr] = false\n    }\n    \n    //  check if route is actually released before returning -> need for remote implementation\n    while (active_routes[_route_nr]) {\n        //  keep on trying to release the route\n        \n    }\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  check if routes are crossing, claim route if crossing path is free\n// ---------------------------------------------------------------------------------------------------------\nfunction check_routes(_loc: number, _dest: number, _id: number): boolean {\n    let i: number;\n    let _route_nr: number;\n    let _r1: boolean;\n    let _r2: boolean;\n    if (CollisionDetection) {\n        return true\n    }\n    \n    let proceed = true\n    //  check start location of route\n    //  is route valid and in route list]\n    let _route = [_loc, _dest]\n    // if _route in [r for r in routes]: # not compatible with makecode\n    let _found = false\n    for (i = 0; i < routes.length; i++) {\n        if (_route == routes[i] && routes[i] != [0, 0]) {\n            _found = true\n        }\n        \n    }\n    if (_found) {\n        //  get route nr\n        _route_nr = _py.py_array_index(routes, _route)\n        // _r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        // _r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = false\n        _r2 = false\n        for (i = 1; i < crossing_routes.length; i++) {\n            if (_route_nr == crossing_routes[i][0]) {\n                _r1 = true\n            }\n            \n            if (_route_nr == crossing_routes[i][1]) {\n                _r2 = true\n            }\n            \n        }\n        if (_r1 || _r2) {\n            proceed = false\n            for (i = 1; i < crossing_routes.length; i++) {\n                if (_route_nr == crossing_routes[i][0]) {\n                    if (!active_routes[crossing_routes[i][1]]) {\n                        active_routes[_route_nr] = true\n                        crossed_routes[_route_nr] = false\n                        proceed = true\n                    } else {\n                        crossed_routes[_route_nr] = true\n                    }\n                    \n                }\n                \n                if (_route_nr == crossing_routes[i][1]) {\n                    if (!active_routes[crossing_routes[i][0]]) {\n                        active_routes[_route_nr] = true\n                        crossed_routes[_route_nr] = false\n                        proceed = true\n                    } else {\n                        crossed_routes[_route_nr] = true\n                    }\n                    \n                }\n                \n            }\n        }\n        \n    }\n    \n    return proceed\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  buttons and switches\n// ---------------------------------------------------------------------------------------------------------\ninput.onButtonPressed(Button.A, function on_button_pressed_a() {\n    \n    stopping = false\n    robot.active = true\n    Full_auto = true\n    if (DEBUG) {\n        serial.writeLine(\"button pressed\")\n    }\n    \n    showText(\"ACTIVE\")\n    \n})\n/** \ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n\n */\nfunction leading_zeros(_num: number, _digits: number): string {\n    let _str = \"0\"\n    _num = Math.round(_num)\n    if (_num < 0) {\n        _num += 256\n    }\n    \n    if (_digits == 3) {\n        if (_num < 10) {\n            _str = \"00\" + (\"\" + _num)\n        } else if (_num < 100) {\n            _str = \"0\" + (\"\" + _num)\n        } else if (_num < 1000) {\n            _str = \"\" + _num\n        }\n        \n    }\n    \n    if (_digits == 2) {\n        if (_num < 10) {\n            _str = \"0\" + (\"\" + _num)\n        } else if (_num < 100) {\n            _str = \"\" + _num\n        }\n        \n    }\n    \n    return _str\n}\n\nlet latsprint = input.runningTime()\nfunction print_data() {\n    let t: number;\n    let _cmd: number;\n    let _chk: any;\n    let _str: string;\n    \n    if (DEBUG) {\n        // serial.write_value(\"# \", control.device_serial_number())\n        t = input.runningTime()\n        serial.writeValue(\"t : \", t / 1000)\n        serial.writeValue(\"dt: \", (t - latsprint) / 1000)\n        latsprint = t\n        serial.writeLine(\"speed \" + robot.speed)\n        serial.writeLine(\"yaw speed \" + robot.yaw_speed)\n        serial.writeLine(\"distance target\" + robot.distance_to_target)\n        serial.writeValue(\"state\", robot.state)\n        serial.writeLine(state_names[robot.state])\n        serial.writeLine(\"\" + \"target \" + (\"\" + robot.target) + (\"\" + \"  \") + locationnames[robot.target])\n        serial.writeValue(\"distance\", robot.distance_to_target)\n        serial.writeValue(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = leading_zeros(robot.id, 2) + (\"\" + _cmd) + (\"\" + robot.state) + leading_zeros(robot.location, 2) + leading_zeros(robot.destination, 2) + leading_zeros(robot.target, 2) + leading_zeros(robot.distance_to_target, 3) + leading_zeros(robot.speed, 3) + (\"\" + _chk) + \"\\r\\n\"\n        serial.writeLine(_str)\n        serial.writeLine(\"--\")\n    }\n    \n    \n}\n\n/** loops.every_interval(500, print_data) */\n/** \ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n\n */\nradio.onReceivedString(function on_radio_received(receivedString: string) {\n    let _cmd: number;\n    \n    //  cmd reply\n    //  0123456\n    //  1,1,1,1\n    //  optimised without string split, and earlier reject of message\n    //  radio_rx_data = receivedString\n    if (receivedString[0] == \"\" + robot.id) {\n        // if DEBUG: serial.write_line(\"this is for us\")\n        if (DEBUG) {\n            serial.writeLine(\"rx:\" + receivedString)\n        }\n        \n        // data = radio_rx_data.split(',')\n        // for d in range (len(data)):\n        //     if DEBUG: serial.write_line(data[d])\n        // _id = int(data[0])\n        // if _id == robot.id:\n        //  this message is send for us\n        // _cmd = int(data[1])\n        _cmd = parseInt(receivedString[2])\n        if (_cmd == 0) {\n            //  send status report or pending command\n            // robot.cmd = STATUS_UPDATE\n            \n        } else if (_cmd == 1) {\n            //  NOK/OK claim destination reply\n            //  data[2] = NOK/OK, data[3] = claimed id\n            // if int(data[3]) == robot.id:\n            if (parseInt(receivedString[6]) == robot.id) {\n                robot.reply = OK\n                robot.cmd = 0\n            }\n            \n            //  no more commands\n            \n        } else if (_cmd == 2) {\n            //  ACK releaseposition\n            // if int(data[2]) == 2:\n            if (parseInt(receivedString[4]) == 2) {\n                robot.reply = ACK\n                robot.cmd = 0\n            }\n            \n            \n        } else if (_cmd == 3) {\n            //  ACK releaseroute\n            // if int(data[2]) == 2:\n            if (parseInt(receivedString[4]) == 2) {\n                robot.reply = ACK\n                robot.cmd = 0\n            }\n            \n            \n        } else if (_cmd == 4) {\n            //  START driving\n            stopping = false\n            robot.active = true\n            robot.backup_starttime = get_time()\n            \n        } else if (_cmd == 5) {\n            //  STOP driving\n            stopping = true\n            robot.active = false\n            \n        }\n        \n        if (DEBUG) {\n            serial.writeLine(\"reply: \" + (\"\" + robot.reply))\n        }\n        \n        RadioTxPending = false\n        WaitingForReply = false\n        // radio_transmit(robot)\n        // if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5)\n    }\n    \n    //  yield for other processes\n    \n})\nfunction radio_transmit(_robot: Robot = new Robot()) {\n    let _cmd = _robot.cmd\n    let _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    let _str = leading_zeros(robot.id, 2) + (\"\" + _cmd) + (\"\" + robot.state) + leading_zeros(robot.location, 2) + leading_zeros(robot.destination, 2) + leading_zeros(robot.target, 2) + leading_zeros(robot.distance_to_target, 3) + leading_zeros(robot.speed, 3) + (\"\" + _chk) + \"\\r\\n\"\n    //  send 2 times to make sure the message came trough\n    radio.sendString(_str)\n    yield_(100)\n    radio.sendString(_str)\n}\n\n// radio.send_string(\"id:\" + str(robot.id))\n// radio.send_string(\",state:\" + str(robot.state))\n// radio.send_string(str(\",loc:\" ) + str(robot.location))\n// radio.send_string(str(\",des:\" ) + str(robot.destination))\n// radio.send_string(str(\",tar:\" ) + str(robot.target))\n// radio.send_string(\"\\r\\n\" )\n// radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n// loops.every_interval(250, on_every_interval)\nfunction yield_(_t: number = 50) {\n    basic.pause(_t)\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  actual main loop\n// ---------------------------------------------------------------------------------------------------------\nlet stopping = false\nradio.setGroup(1)\nclose_gripper()\nlet RadioTxTime = input.runningTime()\nlet WaitingForReply = false\n//  function for getting data from huskylens and function for frame buffer\n// ---------------------------------------------------------------------------------------------------------\nfunction get_frame_data(inview: number): number[] {\n    let tag: number;\n    let x: number;\n    let y: number;\n    let w: number;\n    let h: number;\n    \n    for (tag = 0; tag < inview; tag++) {\n        tagsInView.push(huskylens.readBox_ss(tag + 1, Content3.ID))\n    }\n    if (huskylens.isAppear(robot.target, HUSKYLENSResultType_t.HUSKYLENSResultBlock)) {\n        // volgensmij zit er een bug in robot.target waarbij die soms de verkeerde qr code uitleest als er meerdere  in beeld zijn\n        // de waarde robot.target is een nummer van target die die zoekt\n        // bij de functie husylens.reade_box() moet de volgorde van tag ingevoerd worden die hij ziet(volgensmij)\n        serial.writeLine(\"target \" + (\"\" + robot.target))\n        serial.writeLine(\"\" + tag + \" inview\")\n        x = huskylens.readeBox(robot.target, Content1.xCenter)\n        y = huskylens.readeBox(robot.target, Content1.yCenter)\n        w = huskylens.readeBox(robot.target, Content1.width)\n        h = huskylens.readeBox(robot.target, Content1.height)\n    } else {\n        let [x, y, w, h] = [-1, -1, -1, -1]\n    }\n    \n    return [x, y, w, h]\n}\n\nfunction data_buffer(x: number, y: number, w: number, h: number, tagsInView: number[], reset: boolean): number[][] {\n    \n    //  check if buffer needs to be reset\n    if (frame_count > 3) {\n        reset = true\n    }\n    \n    //  replace buffer data\n    if (reset) {\n        frame_count = 0\n        buffer_xywh = [x, y, w, h]\n        buffer_tagsInView = tagsInView\n    } else {\n        // count frames\n        frame_count = frame_count + 1\n    }\n    \n    //  return buffer data\n    return [buffer_xywh, buffer_tagsInView]\n}\n\n// ---------------------------------------------------------------------------------------------------------\n//  actual main loop\n// ---------------------------------------------------------------------------------------------------------\nstopping = false\nradio.setGroup(1)\nclose_gripper()\nbasic.forever(function on_forever() {\n    \n    if (Full_auto) {\n        robot.active = true\n        stopping = false\n    }\n    \n    if (!stopping && robot.active) {\n        if (robot.cmd == POSITION_UPDATE) {\n            robot.cmd = STATUS_UPDATE\n            radio_transmit(robot)\n            //  send message\n            robot.cmd = NO_CMD\n            robot.active = false\n            //  wait for cleareance by fleet manager\n            stop_robot(robot)\n            stopping = true\n        }\n        \n        if (newdata) {\n            newdata = false\n            do_robot(robot)\n        }\n        \n    }\n    \n    if (HIL_Simulation) {\n        basic.pause(50)\n    }\n    \n    // print_data() -> background loop\n    if (stopping) {\n        robot.active = false\n        stop_robot(robot)\n    }\n    \n    // robot.location = 1\n    // robot.destination = 1\n    // robot.target = 1\n    // robot.objecttype = None\n    // robot.state = IDLE\n    \n})\ncontrol.inBackground(function on_in_background() {\n    \n    //  approx 56 ms -> ~ 18 fps\n    while (1) {\n        // get new frame data\n        huskylens.request()\n        inview = huskylens.getBox(HUSKYLENSResultType_t.HUSKYLENSResultBlock)\n        tagsInView = [0]\n        //  if there is a tag in view, refresh buffer.\n        if (huskylens.isAppear(robot.target, HUSKYLENSResultType_t.HUSKYLENSResultBlock)) {\n            let ___tempvar15 = get_frame_data(inview)\n            x = ___tempvar15[0]\n            y = ___tempvar15[1]\n            w = ___tempvar15[2]\n            h = ___tempvar15[3]\n            data_buffer(x, y, w, h, tagsInView, true)\n        } else {\n            //  if there is no tag in view use latest buffer data\n            let ___tempvar16 = data_buffer(x, y, w, h, tagsInView, false)\n            let box = ___tempvar16[0]\n            tagsInView = ___tempvar16[1]\n            let ___tempvar17 = [box[0], box[1], box[2], box[3]]\n            x = ___tempvar17[0]\n            y = ___tempvar17[1]\n            w = ___tempvar17[2]\n            h = ___tempvar17[3]\n        }\n        \n        newdata = true\n    }\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":54010,"length2":1}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"\n"],[-1,"CollisionDetection = False\nRandomDestination = True # random object or object based on own ID\nHIL_Simulation = False    # run code on\nFirstClaimDestination = True # True: wait for destination area te be cleared.\n                             # False: turn towards destination even if it is occupied\nUseFleetmanager = False\nFull_auto = False\nID = 4\n\nDEBUG = False\n\nUseHusky = True\nDisplayDelay = 200\n\ndef showText(txt):\n    #if not HIL_Simulation:\n    if UseHusky:\n        txt = str(ID) + ' ' + txt\n        huskylens.clear_osd()\n        huskylens.write_osd(txt, 30, 30)\n        if HIL_Simulation: basic.pause(DisplayDelay)\n\n\n######################################\nserial.redirect_to_usb()\nserial.write_string(\"I am alive\")\nif not HIL_Simulation or UseHusky:\n    huskylens.init_i2c()\n    huskylens.init_mode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\nbasic.pause(1000)\n######################################\n# number of robots\nnumrobots = 1\n# number of 'plastic' object types\nnumobjects = 4 # should be an even number for now\nnumtargets = numobjects\n# buffer zones for wating robots\n# 1 robot = 1 waiting\n# 2 robot = 1 waiting, 1 on storage location\n# 3 robot = 3 waiting, 1 left, 1 right 1 central\n# 4 robot = 5 waiting, 2 left, 2 right, 1 central\n# 5 robot = 7 waiting, 3 left, 3 right, 1 central\n# 6 robot = 9 waiting, 4 left, 4 right, 1 central\n# 7 robot = 11 waiting, 5 left, 5 right, 1 central\n# 8 robots = 13 waiting, 6 left, 6 right, 1 central\nif numrobots == 1:\n    numwaitingareas = 5 # adjust to demo\nelse:\n    numwaitingareas = max(3,(numrobots-1)*2 -1) # 1 central waiting area offset to the front\nnumstorage = 1 # try increasing this in future scenarios, attack waste-pile from multiple locations\n# total number of locations where robots can go\nnumlocations = numwaitingareas + numstorage + numtargets + numobjects\n\n\n# constants\nIDLE = 0\nDRIVEBACKWARD = 1\nFINDTARGET = 2\nGOTOTARGET = 3\nFINDOBJECT = 4\nGRABOBJECT = 5\n\nLOCATION_t = 0 # robot is looking for location\nOBJECT_t = 1   # robot is looking for object\n\nOPENED = 1\nCLOSED = 0\n\nAHEAD = 0\nLEFT  = 1\nRIGHT = 2\n\nMAXSPEED = 22\nMINSPEED = 15\nMINYAWSPEED = 8\nMAXYAWSPEED = 14\nBACKUPSPEED = -20\nBACKUPDISTANCE = 20\n\nOBJECT_THRESHOLD = 0 # minimum distance to object, before closing grippers\n\nstate_names = ['IDLE', 'DRIVEBACKWARD', 'FINDTARGET', 'GOTOTARGET', 'FINDOBJECT', 'GRABOBJECT']\ndirection_names = ['AHEAD', 'LEFT', 'RIGHT']\ncmd_names = ['STATUS_UPDATE','CLAIM_DESTINATION','RELEASE_POSITION','RELEASE_ROUTE','ROBOT_START','ROBOT_STOP']\nrply_names = ['NOK','OK','ACK']\n\n# commands\nNO_CMD = -1\nPOSITION_UPDATE = 10\nSTATUS_UPDATE = 0\nCLAIM_DESTINATION = 1\nRELEASE_POSITION = 2\nRELEASE_ROUTE = 3\nROBOT_START = 4\nROBOT_STOP = 5\nNOK = 0\nOK = 1\nACK = 2\n\n#initialize variables related to huskylens\nt_start = 0\nt_last = 0\ndt_AI = 0\ninview = 0\nx = 0\ny = 0\nw = 0\nh = 0\nnewdata = False\ninview_count = 0\nRadioTxPending = False\ntagsInView = [0]\nframe_count = 0\nbuffer_xywh = [-1,-1,-1,-1]\nbuffer_tagsInView = [0]\n\ntagID = 1\n# tagIDs = [1 tm 6]\n# tuning per robot, mainly sotrage area\nif ID == 1:\n    tagSizes = [0,  88, 90, 90, 90, 88,  87,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\nif ID == 2:\n    tagSizes = [0,  88, 90, 90, 90, 83,  87,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\nif ID == 3:\n    tagSizes = [0,  88, 90, 90, 90, 86,  87,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\nif ID == 4:\n    tagSizes = [0,  88, 90, 90, 90, 86,  87,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\n\ntagSize = tagSizes[tagID]\n\nzeroes = [0]\nwhile i < len(tagSizes):\n    zeroes.append(0)\n    i += 1\ntagsInView = zeroes\n#start_searching = 0\n\n\n#---------------------------------------------------------------------------------------------------------\n# helper function to open and close grippers, will be different on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef open_gripper():\n    opengripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 85)\n    return opengripper\n\n\ndef close_gripper():\n    closegripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 105)\n    return closegripper\n\ndef actuate_motors():\n    if HIL_Simulation: return True\n\n    left_speed = (robot.speed + robot.yaw_speed)\n    right_speed = (robot.speed + -robot.yaw_speed)\n    #serial.write_line(str(left_speed)+\" left speed\")\n    #serial.write_line(str(right_speed)+\" right speed\")\n    # set speed for motors here\n    if left_speed >=0:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    if right_speed >=0:\n       maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n\n    return True\n\ndef get_time():\n    return input.running_time()\n\n#---------------------------------------------------------------------------------------------------------\n# base class of robot, can also be used on micro:Maqueen robot.\n# Robot() class, should be same for offline Simulation and actual physical demo robot\n#---------------------------------------------------------------------------------------------------------\nclass Robot:\n    def __init__(self, loc=1, dst=1, _id=1):\n        # who are we\n        self.id = _id\n        # ego location and destination nr\n        self.location = loc\n        self.destination = dst\n        self.target = dst\n        self.targettype = LOCATION_t\n        self.objecttype = None\n        # states\n        self.state = IDLE\n        self.gripper = CLOSED\n        self.speed = 0\n        self.yaw_speed = 0\n        # params\n        self.active = False\n        self.run_enable = False\n        self.steering_only = False # allowed to change heading but not driving\n        self.target_direction = LEFT\n        self.target_inview = False  # target is in view of camera\n        self.target_locked = False # target is straight ahead\n        self.backup_distance = 0\n        self.distance_to_target = 0\n        self.backup_starttime = 0\n        self.looking_for_object = 0\n        self.route_length = 0\n        self.route_reported = False\n        self.obstacle_detected = False\n        self.cmd = 0\n        self.reply = 0\n\n    def gripper_open(self):\n        if open_gripper():\n            self.gripper = OPENED\n        pass\n\n    def gripper_close(self):\n        if close_gripper():\n            self.gripper = CLOSED\n        pass\n\n#---------------------------------------------------------------------------------------------------------\n# pre allocate robot instance as global\n#---------------------------------------------------------------------------------------------------------\nrobot = Robot( loc=ID, dst=ID, _id=ID)\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_heading(_robot=Robot()):\n\n    #angle error in pixels\n    # x = position of tag in camera view, 320 wide, 160 is center\n    if HIL_Simulation:\n        basic.pause(100)\n        return 0\n        \n    angle_err = 160-x\n    \n    return angle_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_distance(_robot=Robot()):\n    '''\n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    '''\n    tagSize = tagSizes[_robot.target]\n    tagID = _robot.target\n    \n    if HIL_Simulation:\n        if not _robot.state == DRIVEBACKWARD:\n            distance_measured = _robot.distance_to_target - _robot.speed # drive towards target\n        else:\n            distance_measured = _robot.distance_to_target + abs(_robot.speed) # drive away from target\n    else :\n        distance_measured = tagSize - h  # height of tag - height of tag measured\n        #serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    \n    distance_measured = max(distance_measured,0) # distance cannot be negative\n\n    return distance_measured\n    \n\n#---------------------------------------------------------------------------------------------------------\n# look for target and aim robot towards it, different in offline Simulation vs actual robot\n#---------------------------------------------------------------------------------------------------------\ndef find_target(_robot=Robot()):\n    # We are driving towards a location\n    if _robot.targettype == LOCATION_t:\n        _robot.target = _robot.destination\n    # We are looking for and driving to an object\n    if _robot.targettype == OBJECT_t:\n        # start looking for the object\n        _robot.target = obj[_robot.objecttype] # obj location nr will become new target\n\n    _robot.steering_only = True\n    # set preffered turning direction?\n    # actuate drive and steering\n\n    _dist = move_robot(_robot)\n    return _dist\n\n#---------------------------------------------------------------------------------------------------------\n#function to search target\n#---------------------------------------------------------------------------------------------------------\ndef pulse(_dir=LEFT,_robot=Robot()):\n    #pulsing behaviour\n    pulse_duration = 700  # Duration of one complete pulse cycle\n    active_ratio = 0.2  # Ratio of time the robot is actively turning within a pulse\n    base_speed = 15\n    speed_multiplier = 1.25\n\n    if robot.state == FINDOBJECT:\n        speed_multiplier = 1.2\n        if robot.looking_for_object == 0:\n            _robot.looking_for_object = input.running_time()\n        else:\n            time_looking = input.running_time() - _robot.looking_for_object\n            if time_looking < 2000:\n                 _dir = LEFT\n            else: _dir = RIGHT\n\n\n\n\n    #if start_searching == 0: # als\n    #    start_searching = input.running_time()\n    \n    #calculate searching time\n    #searching_time = input.running_time() - start_searching\n    # Calculate the phase of the pulse (0 to 1)\n    pulse_phase = (input.running_time() % pulse_duration) / pulse_duration\n\n    #calculate if we are in the active part of the pulse\n    is_active_pulse = pulse_phase < active_ratio\n\n    if is_active_pulse:\n        # During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    else:\n        # During inactive pulse: stand still\n        turn_speed = base_speed\n\n    if _dir == LEFT: turn_speed = -turn_speed\n\n    return turn_speed\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n#---------------------------------------------------------------------------------------------------------\n# actual motion control, aim for target, with or without speed\n#---------------------------------------------------------------------------------------------------------\ndef move_robot(_robot=Robot()):\n\n    #check if robot is allowed to move\n    dist_err = 999 # default distance error\n    if not _robot.run_enable:\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n    #check if target is in sight\n    if (_robot.target in tagsInView) or HIL_Simulation or (_robot.target in buffer_tagsInView) :\n            _robot.target_inview = True\n                                              \n    else:\n        # add timeout before target is no longer in view???\n        _robot.target_inview = False\n        _robot.target_locked = False\n\n\n    #if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if not _robot.target_inview:\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction,_robot)\n    # if target is in view\n    else:\n        # heading / steering control\n        angle_err = calc_heading(_robot) # how many pixels are we off centre\n        dist_err = calc_distance(_robot) # how many pixels are we away from target\n        _robot.distance_to_target = dist_err # store on instance of robot, for logistical and rouet handling\n\n        # heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp # simple P-control of heading angle\n        if _robot.target_locked:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n        else:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n\n        # speed control, start driving when target is almost straight ahead of robot\n        if abs(angle_err) < 20:\n            _robot.yaw_speed = 0\n            _robot.target_locked = True\n            # speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = min(dist_err * Kp, MAXSPEED)\n            # drive slow when approaching an object\n            if _robot.state == GRABOBJECT: _robot.speed = min(MINSPEED, _robot.speed * Kp)\n            \n        else:\n            _robot.target_locked = False\n\n        # steering only when aiming for target\n        if _robot.steering_only:\n            _robot.speed = 0\n\n        # if obstacle detected stop robot\n        if CollisionDetection and collision_detected(_robot):\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n        # adjust turning speed depening on driving or turning when standing still\n        if _robot.speed > 0 :\n            # while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = max(-MINYAWSPEED/4, min(_robot.yaw_speed, MINYAWSPEED/4))\n\n        else:\n            # turn while standing still, use minimum turning speed\n            if  _robot.yaw_speed > 0:\n                if _robot.yaw_speed < MAXYAWSPEED: _robot.yaw_speed = MAXYAWSPEED\n            if  _robot.yaw_speed < 0:\n                if _robot.yaw_speed > -MAXYAWSPEED: _robot.yaw_speed = -MAXYAWSPEED\n\n    actuate_motors()\n    return dist_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# actively stop robot\n#---------------------------------------------------------------------------------------------------------\ndef stop_robot(_robot=Robot()):\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n\n#---------------------------------------------------------------------------------------------------------\n# drive backward to clear storage or target areas\n#---------------------------------------------------------------------------------------------------------\ndef reverse_robot(_robot=Robot()):\n    dist_err = calc_distance(_robot)\n    # drive straight backward, without steering\n    _robot.yaw_speed = 0\n    # have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.running_time() - _robot.backup_starttime) < 750: # 0.75 seconds\n        _robot.looking_for_object = 0\n    #if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = False\n    else:\n        _finished = True\n        _robot.speed = 0\n    actuate_motors()\n    return _finished\n\n\n#---------------------------------------------------------------------------------------------------------\n# run robot main code (similar to real-time implementation)\n#---------------------------------------------------------------------------------------------------------\ndef do_robot(_robot=Robot()):\n    # statemachine\n    if _robot.state == IDLE:\n        _robot.run_enable = False\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = POSITION_UPDATE\n        stop_robot(_robot)\n        if _robot.active:\n            # we are allowed to drive\n            _robot.run_enable = True\n            # request next destination, if we cary an object we are going to an output stream area\n            result = next_destination( _robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            if _robot.location != waitingarea[3]:\n                _robot.target_direction = result[1]\n            _robot.target = _robot.destination\n            # if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            # maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            # when the robot has reased its starting position (claim released) the QR code should be visible\n            if _robot.location in waitingarea:\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET  # directly start aiming for next destination\n                #serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n                # for HIL_Simulation only\n                if HIL_Simulation:\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n\n            else:\n                # backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                #serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD  # drive backwards first\n                _robot.backup_starttime = get_time() # input.running_time()\n                # if wa are at target area, weh open gripper and drive backward to leave object there\n                if _robot.location in target[1:numtargets+1]:\n                    _robot.gripper_open()\n                    _robot.objecttype = None # we leave the object here\n                    pass\n                #elif _robot.location in storagearea:\n                # randomly assign new object to location where last object was taken from\n                #    nxt_object = randint(1, numobjects+1)\n                #    waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                #    waste_object[_robot.objecttype].objecttype = nxt_object\n                #    pass\n                else:\n                    # all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    pass\n                # for HIL_Simulation only\n                if HIL_Simulation: _robot.distance_to_target = 0\n        pass\n    elif _robot.state == DRIVEBACKWARD:\n        # drive backwards\n        if reverse_robot(_robot):\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            # for HIL_Simulation only\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n        pass\n    elif _robot.state == FINDTARGET:\n        # find target by rotating robot, but do not drive\n        _proceed = False\n        if FirstClaimDestination:\n             if UseFleetmanager:\n                 _robot.cmd = CLAIM_DESTINATION\n                 if _robot.reply == OK:\n                     _robot.reply = 0 # reset for next command\n                     _proceed = True\n                     _robot.cmd = STATUS_UPDATE\n                 pass\n             else:\n                if claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                    _proceed = True\n        else:\n            _proceed = True\n\n        if _proceed:\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            # when we have found the target, we are going to drive towards it\n            if _robot.target_locked:\n                # we have found the target, re-check if it is clear to drive there\n                #if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if not FirstClaimDestination:\n                    _proceed = False\n                    if CollisionDetection:\n                        _proceed = True\n                    elif UseFleetmanager:\n                        _robot.cmd = CLAIM_DESTINATION\n                        if _robot.reply == OK:\n                            _robot.reply = 0 # reset for next command\n                            _proceed = True\n                            _robot.cmd = STATUS_UPDATE\n                        pass\n                    elif claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                            _proceed = True\n                if _proceed:\n                    showText(\"GOTOTARGET: \" + str(_robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = False\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n        pass\n    elif _robot.state == GOTOTARGET:\n        # make sure we keep claim on target area\n        _robot.steering_only = False\n        _dist_to_travel = move_robot(_robot)\n        _proceed = False\n        _robot.cmd = STATUS_UPDATE\n        # report route haflway, only onetime reporting\n        if _dist_to_travel < _robot.route_length/2 and not _robot.route_reported:\n            if UseFleetmanager:\n                _robot.route_reported = True\n                pass # do not report release position\n                '''\n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n                '''\n            else:\n                release_position(_robot.location)\n                _robot.route_reported = True\n        _robot.distance_to_target = _dist_to_travel\n        # if we approach storage, open gripper before reaching destination\n        if _robot.destination in storagearea:\n            if _dist_to_travel == 0:\n                _robot.state = FINDOBJECT\n                # assign an object to look for\n                if RandomDestination:\n                    _robot.objecttype = randint(1, numobjects) # a random object is assigned to robot\n                else:\n                    _robot.objecttype = _robot.id  # robot ID determines object types to be retrieved\n                # switch state and start looking for object\n                showText(\"FINDOBJECT: \" + str(_robot.objecttype))\n                pass\n        elif _dist_to_travel <= 0+5:\n            # target reached, release route\n            _proceed = False\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route gototarget\")\n                if DEBUG: serial.write_line(\"reply: \" + str(_robot.reply))\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n        pass\n    elif _robot.state == FINDOBJECT:\n        # Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = True\n        # if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if _robot.target_locked:\n            _robot.steering_only = False\n                                                     \n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + str(_robot.objecttype))\n            \n    elif _robot.state == GRABOBJECT:\n        _dist_to_travel = move_robot(_robot)\n        if _dist_to_travel <= OBJECT_THRESHOLD+5:\n                                                      \n            _robot.gripper_close()\n            _proceed = False\n            # target reached, release route\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route grabobject\")\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                # switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n        pass\n\n\n#---------------------------------------------------------------------------------------------------------\n# collision detection, can be based on camera or sensor on robot\n#---------------------------------------------------------------------------------------------------------\ndef collision_detected(_robot=Robot()):\n    #\n    # Needs implementing on robot\n    #\n    _robot.obstacle_detected = False\n    obstacle_detected = False\n    return obstacle_detected\n\n\n\n#---------------------------------------------------------------------------------------------------------\n#\n#  ROUTE HANDLING BELOW\n#\n#---------------------------------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------------------------------\n# locations id's\n#---------------------------------------------------------------------------------------------------------\n\n# ids of waiting areas\nwaitingarea = [0]\nfor i in range(numwaitingareas):\n    waitingarea.append(i+1)\n# ids of storage areas\nstoragearea = [0]\nfor i in range(numwaitingareas, numwaitingareas+numstorage):\n    storagearea.append(i+1)\n# ids of target areas\ntarget = [0]\nfor i in range(numwaitingareas+numstorage, numwaitingareas+numstorage+numtargets):\n    target.append(i+1)\n# ids of objects\nobj = [0]\nfor i in range(numwaitingareas+numstorage+numtargets, numwaitingareas+numstorage+numtargets+numobjects):\n    obj.append(i+1)\n\n#occupation list of all locations\n#occupying = [0]  * (numlocations +1) -> does not work in Makecode\n# for compatibility reasons wit MakeCode on robot, do it like this\noccupying = [0]\nfor i in range(numlocations +1):\n    occupying.append(0)\n\nlocationnames = ['None']\nfor i in range(1,numwaitingareas+1):\n    locationnames.append(str('waitingarea ') + str(i))\nlocationnames.append(str('storage 1'))\nfor i in range(1,numobjects+1):\n    locationnames.append(str('targetarea ') + str(i))\nfor i in range(numobjects+1):\n    locationnames.append(str('object ') + str(i+1))\n\n#---------------------------------------------------------------------------------------------------------\n# instances of routes, using location id's\n#---------------------------------------------------------------------------------------------------------\nroutes = [(0,0)]\nfor i in range(50):\n    routes.append((0,0))\n\n# route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor i in range(numwaitingareas):\n    routes[i] = (waitingarea[1+i], storagearea[1])\noffset = numwaitingareas\nfor i in range(numobjects):\n    routes[i+offset] = (storagearea[1], target[1+i])\noffset += i+1\nfor i in range(numobjects):\n    if i < numobjects/2:\n        routes[i+offset] = (target[i+1], waitingarea[1])\n    else:\n        routes[i + offset] = (target[i+1], waitingarea[len(waitingarea)-1]) # waitingarea[-1] is not compatibel with Makecode\noffset += i+1\nidx = 0\nfor i in range(1, numwaitingareas):\n    if i < numwaitingareas/2:\n        routes[offset+i-1] = (waitingarea[i], waitingarea[i+1]) # shift from left to middle\n        idx = i\n    else:\n        routes[offset+i-1] = (waitingarea[len(waitingarea)-1]-i+idx+1, waitingarea[len(waitingarea)-1]-i+idx) # shift from right to middle\n\n\n# potentially crossing route combinations for additional clearance check\n# crossing routes:\n# - all routes from storage to targets in combination with all targets to waitingarea\n# - combination have to be all on left side or right side, right and left never cross (for now)\ncrossing_routes_ids = [((0,0),(0,0))]\ncrossing_routes = [(0,0)]\nfor i in range(len(routes)):\n    if routes[i][0] == storagearea[1]:\n        for j in range(len(routes)):\n            if routes[j][1] == waitingarea[1]:\n                if routes[j][0]<routes[i][1]:\n                    if routes[i][1] in target[1:int(numtargets/2)+1]:\n                        crossing_routes_ids.append((routes[i],routes[j]))\n                        crossing_routes.append((i, j))\n            if routes[j][1] == waitingarea[len(waitingarea)-1]:\n                if routes[j][0] < routes[i][1]:\n                    if routes[i][1] in target[int(numtargets/2)+1:numtargets+1]:\n                        crossing_routes_ids.append((routes[i], routes[j]))\n                        crossing_routes.append((i, j))\n\nactive_routes = [False]\nfor i in range(len(routes) +1):\n    active_routes.append(False)\ncrossed_routes = [False]\nfor i in range(len(routes) +1):\n    crossed_routes.append(False)\n\n\n#---------------------------------------------------------------------------------------------------------\n# check what next destination will be, this is the route scheduler, might be local or remote implemented\n#---------------------------------------------------------------------------------------------------------\ndef next_destination(_location, objecttype = None):\n    nxt_dest = _location # if there is no new location found, return current position as next destination\n    target_dir = AHEAD\n    # if we pick up an object, object nr tels us where to go\n    if (_location in storagearea) and (objecttype is not None):\n        # were need the collected object go to?\n        nxt_dest = target[objecttype]\n        # is target location left or rigth of us?\n        if nxt_dest in target[1:int(numtargets/2)+1]:\n            target_dir = LEFT\n        elif nxt_dest in target[int(numtargets/2)+1:numtargets+1]:\n            target_dir = RIGHT\n    # if we come from a target to the left, goto left most waiting area\n    elif _location in target[1:int(numtargets/2)+1]:\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    # if we come from a taget to the right, goto right most waiting area\n    elif _location in target[int(numtargets/2)+1:numtargets+1]:\n        nxt_dest = waitingarea[len(waitingarea)-1]\n        target_dir = RIGHT\n    # if we are in the waiting area, move toward the center wating area, before going back to the storage\n    elif _location in waitingarea:\n        # from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for i in range(1,int(numwaitingareas/2)+1):\n            # from left to middle\n            if _location == waitingarea[i]:\n                nxt_dest = waitingarea[i+1]\n                target_dir = LEFT\n            # from right to middle\n            if _location == waitingarea[len(waitingarea)-1]-i+1:\n                nxt_dest = waitingarea[len(waitingarea)-1]-i\n                target_dir = RIGHT\n    return nxt_dest, target_dir\n\n\n#---------------------------------------------------------------------------------------------------------\n# try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n#---------------------------------------------------------------------------------------------------------\ndef claim_destination(_loc=0, _dest=0, _id=0):\n    claimed = 0\n    occupied = occupying[_dest]\n    if occupied == 0 and _id > 0:\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    else:\n        claimed_id = occupying[_dest]\n    if claimed_id == _id > 0:\n        if check_routes(_loc, _dest, _id):\n            occupying[_dest] = _id\n            #release_position(_loc) # this assumes that you start driving imediatly after claim of location\n        else:\n            claimed_id = 0\n    return claimed, claimed_id\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if a destination is occupied, return ID that occupies destination\n#---------------------------------------------------------------------------------------------------------\ndef check_occupied(_dst):\n    claimed, occupied = claim_destination(_dest=_dst)\n    return occupied\n\n\n#---------------------------------------------------------------------------------------------------------\n# release location when you have left it\n#---------------------------------------------------------------------------------------------------------\ndef release_position(_location):\n    occupying[_location] = 0\n    return True\n\n\n#---------------------------------------------------------------------------------------------------------\n# release a route when we finished driving it\n#---------------------------------------------------------------------------------------------------------\ndef release_route(_loc,_dest):\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i]: _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        active_routes[_route_nr] = False\n    # check if route is actually released before returning -> need for remote implementation\n    while active_routes[_route_nr]:\n        # keep on trying to release the route\n        pass\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if routes are crossing, claim route if crossing path is free\n#---------------------------------------------------------------------------------------------------------\ndef check_routes(_loc, _dest, _id):\n    if CollisionDetection: return True\n    proceed = True\n    # check start location of route\n    # is route valid and in route list]\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i] and routes[i] != (0, 0):\n            _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        #_r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        #_r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = False\n        _r2 = False\n        for i in range(1,len(crossing_routes)):\n            if _route_nr == crossing_routes[i][0]: _r1 = True\n            if _route_nr == crossing_routes[i][1]: _r2 = True\n        if _r1 or _r2:\n            proceed = False\n            for i in range(1,len(crossing_routes)):\n                if _route_nr == crossing_routes[i][0]:\n                    if not active_routes[crossing_routes[i][1]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n                if _route_nr == crossing_routes[i][1]:\n                    if not active_routes[crossing_routes[i][0]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n\n    return proceed\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# buttons and switches\n#---------------------------------------------------------------------------------------------------------\n\ndef on_button_pressed_a():\n    global stopping, robot, DEBUG, Full_auto\n    stopping = False\n    robot.active = True\n    Full_auto = True\n    if DEBUG: serial.write_line('button pressed')\n    showText(\"ACTIVE\")\n    pass\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\n'''\ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n'''\n\ndef leading_zeros(_num, _digits):\n    _str = '0'\n    _num = Math.round(_num)\n    if _num < 0: _num += 256\n    if _digits == 3:\n        if _num < 10 :\n            _str = '00' + str(_num)\n        elif _num < 100:\n            _str = '0' + str(_num)\n        elif _num < 1000:\n            _str = str(_num)\n    if _digits == 2:\n            if _num < 10 :\n                _str = '0' + str(_num)\n            elif _num < 100:\n                _str = str(_num)\n    return _str\n\nlatsprint = input.running_time()\n\ndef print_data():\n    global robot, DEBUG, latsprint\n    if DEBUG:\n        #serial.write_value(\"# \", control.device_serial_number())\n        t = input.running_time()\n        serial.write_value(\"t : \",t/1000)\n        serial.write_value(\"dt: \", (t-latsprint)/1000)\n        latsprint = t\n        serial.write_line(\"speed \"+robot.speed)\n        serial.write_line(\"yaw speed \"+robot.yaw_speed)\n        serial.write_line(\"distance target\"+robot.distance_to_target)\n        serial.write_value(\"state\", robot.state)\n        serial.write_line(state_names[robot.state])\n        serial.write_line(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target])\n        serial.write_value(\"distance\", robot.distance_to_target)\n        serial.write_value(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                    leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                    leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n        serial.write_line(_str)\n        serial.write_line('--')\n    pass\n'''\nloops.every_interval(500, print_data)\n'''\n\n'''\ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n'''\n\ndef on_radio_received(receivedString):\n    global robot, stopping, DEBUG, RadioTxPending, WaitingForReply\n    # cmd reply\n    # 0123456\n    # 1,1,1,1\n    # optimised without string split, and earlier reject of message\n    # radio_rx_data = receivedString\n    if receivedString[0] == str(robot.id):\n        #if DEBUG: serial.write_line(\"this is for us\")\n        if DEBUG: serial.write_line(\"rx:\" + receivedString)\n        #data = radio_rx_data.split(',')\n        #for d in range (len(data)):\n        #    if DEBUG: serial.write_line(data[d])\n        #_id = int(data[0])\n        #if _id == robot.id:\n        # this message is send for us\n        #_cmd = int(data[1])\n        _cmd = int(receivedString[2])\n        if _cmd == 0:\n            # send status report or pending command\n            #robot.cmd = STATUS_UPDATE\n            pass\n        elif _cmd == 1:\n            # NOK/OK claim destination reply\n            # data[2] = NOK/OK, data[3] = claimed id\n            #if int(data[3]) == robot.id:\n            if int(receivedString[6]) == robot.id:\n                robot.reply = OK\n                robot.cmd = 0 # no more commands\n            pass\n        elif _cmd == 2:\n            # ACK releaseposition\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 3:\n            # ACK releaseroute\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 4:\n            # START driving\n            stopping = False\n            robot.active = True\n            robot.backup_starttime = get_time()\n            pass\n        elif _cmd == 5:\n            # STOP driving\n            stopping = True\n            robot.active = False\n            pass\n\n        if DEBUG: serial.write_line(\"reply: \" + str(robot.reply))\n        RadioTxPending = False\n        WaitingForReply = False\n        #radio_transmit(robot)\n        #if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5) # yield for other processes\n    pass\nradio.on_received_string(on_radio_received)\n\n\ndef radio_transmit(_robot=Robot()):\n    _cmd = _robot.cmd\n    _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n    # send 2 times to make sure the message came trough\n    radio.send_string(_str)\n    yield_(100)\n    radio.send_string(_str)\n\n    #radio.send_string(\"id:\" + str(robot.id))\n    #radio.send_string(\",state:\" + str(robot.state))\n    #radio.send_string(str(\",loc:\" ) + str(robot.location))\n    #radio.send_string(str(\",des:\" ) + str(robot.destination))\n    #radio.send_string(str(\",tar:\" ) + str(robot.target))\n    #radio.send_string(\"\\r\\n\" )\n    #radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n#loops.every_interval(250, on_every_interval)\n\ndef yield_(_t=50):\n    basic.pause(_t)\n\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\nRadioTxTime = input.running_time()\nWaitingForReply = False\n\n# function for getting data from huskylens and function for frame buffer\n#---------------------------------------------------------------------------------------------------------\ndef get_frame_data(inview):\n    global tagsInView\n    for tag in range(inview):\n        tagsInView.append(huskylens.readBox_ss(tag + 1, Content3.ID))\n    if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n    #volgensmij zit er een bug in robot.target waarbij die soms de verkeerde qr code uitleest als er meerdere  in beeld zijn\n    #de waarde robot.target is een nummer van target die die zoekt\n    #bij de functie husylens.reade_box() moet de volgorde van tag ingevoerd worden die hij ziet(volgensmij)\n        serial.write_line(\"target \"+str(robot.target))\n        serial.write_line(str(tag)+' inview')\n        x = huskylens.reade_box(robot.target, Content1.X_CENTER)\n        y = huskylens.reade_box(robot.target, Content1.Y_CENTER)\n        w = huskylens.reade_box(robot.target, Content1.WIDTH)\n        h = huskylens.reade_box(robot.target, Content1.HEIGHT)\n       \n    else:\n        x,y,w,h = -1,-1,-1,-1\n\n    return x,y,w,h\n    \ndef data_buffer(x,y,w,h,tagsInView,reset):\n        global frame_count, buffer_xywh, buffer_tagsInView\n        # check if buffer needs to be reset\n        if frame_count > 3:\n            reset = True\n        # replace buffer data\n        if reset:\n            frame_count = 0\n            buffer_xywh = [x,y,w,h]\n            buffer_tagsInView = tagsInView\n        #count frames\n        else:\n            frame_count = frame_count + 1\n        # return buffer data\n        return buffer_xywh,buffer_tagsInView\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\n\ndef on_forever():\n\n    global stopping, HIL_Simulation, robot, newdata, Full_auto\n    if Full_auto:\n        robot.active = True\n        stopping = False\n    if not stopping and robot.active:\n        if (robot.cmd == POSITION_UPDATE):\n            robot.cmd = STATUS_UPDATE\n            radio_transmit(robot) # send message\n            robot.cmd = NO_CMD\n            robot.active = False # wait for cleareance by fleet manager\n            stop_robot(robot)\n            stopping = True\n        if newdata:\n            newdata = False\n            do_robot(robot)\n\n    if HIL_Simulation: basic.pause(50)\n    #print_data() -> background loop\n    if stopping:\n        robot.active = False\n        stop_robot(robot)\n        #robot.location = 1\n        #robot.destination = 1\n        #robot.target = 1\n        #robot.objecttype = None\n        #robot.state = IDLE\n    pass\nbasic.forever(on_forever)\n\ndef on_in_background():\n    global inview, tagsInView, x, y, w, h, newdata\n    # approx 56 ms -> ~ 18 fps\n\n    while 1:\n        #get new frame data\n        huskylens.request()\n        inview = huskylens.get_box(HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK)\n        tagsInView = [0]\n        \n        # if there is a tag in view, refresh buffer.\n        if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n            x,y,w,h = get_frame_data(inview)\n            data_buffer(x,y,w,h,tagsInView,True)\n\n        # if there is no tag in view use latest buffer data\n        else:\n            box,tagsInView = data_buffer(x,y,w,h,tagsInView,False)\n            x,y,w,h=box[0],box[1],box[2],box[3]\n\n        newdata = True\n\n                          \ncontrol.in_background(on_in_background)\n"]],"start1":0,"start2":0,"length1":46911,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.7\",\n        \"maqueen\": \"github:dfrobot/pxt-maqueen#v1.7.14\""],[0,"\n   "]],"start1":160,"start2":160,"length1":133,"length2":8},{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":248,"start2":248,"length1":52,"length2":8},{"diffs":[[0,"on-only\""],[1,",\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":316,"start2":316,"length1":11,"length2":42}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1738336695892,"editorVersion":"7.0.57","text":{"main.ts":"","README.md":"","main.py":"\n","pxt.json":"{\n    \"name\": \"MPPS_demonstrator_python_only_v09\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\",\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1738336738348}